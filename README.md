### Welcome

Here are collections of personal code I've published to allow me to use at companies I've worked with/for without loosing my intellectual property.

I've been a professional computer programmer since the late '70s.
I read about UNIX and the C programming language and looked for a way to use them.
After purchasing a micro computer in the early '80s that included them, I was hooked.
And, now, so is most of the computer world.

C is: Mature. Stable. Ubiquitous.
Often described as a portable assembly language,
C translates directly to processor instructions and is: Fast. Small. Efficient.
Why program a computer in any other language?
Is C too close to the processor?

You will find a couple repositories that take full advantage of the closeness, the callback parsers.
They have no dependences.
Not even the C library.
They are pure C functions that get down and dirty to rip through XML and JSON.

There is a repository that helps free C from the call graph.
(In my opinion C's primary weakness.)
Using POSIX threads (almost as ubiquitous as C), channels enable a style of programming that is exploited in more modern programming languages.
What about lazy evaluation?

And, as C operations map to instructions, C structures organize memory for efficient access.
Processing rich information models is possible but tedious, at best.
There is a much better language for handling data.
And it's almost as mature, stable and ubiquitous as C.
SQL.
The [SQLite](https://sqlite.org) library is an indespensible tool for the C programmer.
Providing declarative programming for data rich C.
A couple of the repositories marry the XML and JSON callback parsers with SQL to provide DOM capabilities.

Lastly, I'm starting to work through an AI textbook.
It's hard getting time to work on it.
Wish me luck.
